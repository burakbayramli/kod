<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_08) on Thu Aug 03 10:07:22 CEST 2006 -->
<TITLE>
CFmt
</TITLE>

<META NAME="keywords" CONTENT="CFmt class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="CFmt";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="Precompile.html" title="class in "><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="CFmt.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
Class CFmt</H2>
<PRE>
java.lang.Object
  <IMG SRC="./resources/inherit.gif" ALT="extended by"><B>CFmt</B>
</PRE>
<HR>
<DL>
<DT>public class <B>CFmt</B><DT>extends java.lang.Object</DL>

<P>
CFmt: Formatting strings and numbers like printf in C.<P>

 The first purpose of this class is to ease the migration of C-programs
 regarding the printf family. I needed this kind of class, but I am not
 very experienced in Java, so if anyone sees very funny kind of programming
 style in parts of this class, he / she should tell me about an alternative.
 Same thing applies to any errors in programming or erronous behaviour of
 the class.<P>

 This class is meant to be completely public domain - do whatever you
 like to do with it, but if you would like to see some improvements or
 if you implemented some improvements, I would like to know of it as well.<P>

 Thomas Mack, May 1999<BR>
 mack@ifis.cs.tu-bs.de<P>



 <B>Introduction:</B><P>

 The format specifier splits up into 5 parts: '%'; flags '-', '+', ' ', '#';
 minimum fieldwidth; "." + precision; type specifier (c (char), s (string),
 d,i,o,u,p,x,X (integer numbers), f,e,E,g,G (real numbers)). "%" and type
 specifier are necessary, all others are optional.<P>

 For further info see the excerpt of the manpage below.<P>

 <B>Examples:</B><P>

 <CODE>
 CFmt cv = new CFmt();<BR>
 System.out.println("Int:    '"+ cv.fmt("%17d",-653)+"'";<BR>
 System.out.println("Int:    '"+ cv.fmt("%17X", 653)+"'";<BR>
 System.out.println("Int:    '"+ cv.fmt("%#17x", 653)+"'";<BR>
 System.out.println("Double: '"+ cv.fmt("%17.4f",-653.0)+"'";<BR>
 System.out.println("Double: '"+ cv.fmt("%-17.4e",-653.0)+"'";<BR>
 System.out.println("Double: '"+ cv.fmt("%17.4G",-653.0)+"'";<BR>
 System.out.println("Double: '"+ cv.fmt("%#17.4G",-653.0)+"'";<BR>
 System.out.println("String: '"+ cv.fmt("%17.10s","I like it! (Do I?)")+"'";<BR>
 System.out.println("Char:   '"+ cv.fmt("%-5c",'Y')+"'";<BR>
 </CODE><P>


 Output:

 <P><CODE>
 Int:    '             -653'<BR>
 Int:    '              28D'<BR>
 Int:    '            0x28d'<BR>
 Double: '        -653.0000'<BR>
 Double: '-6.5300e+02      '<BR>
 Double: '             -653'<BR>
 Double: '           -653.0'<BR>
 String: '       I like it!'<BR>
 Char:   'Y    '<BR>
 </CODE><P>

 Read the relevant excerpt of the man(ual)page for printf further below
 for a rather complete description of the formatting options.<P>



 <B>Behaviour that is different to C under Solaris 2.6:</B><P>

 <UL>
 <LI> Hexadecimal numbers (type 'x', 'X' und 'p') in C will be displayed
   with max. 4 Bytes, in Java with max. 8 bytes:<P><CODE>

     Java (x): ffffffffffffffff   [-1 decimal]<BR>
     &nbsp;&nbsp;&nbsp;C (x):         ffffffff   [-1 decimal]</CODE><P>

   Same behaviour applies to octal numbers (type 'o'):<P><CODE>

   Java (o): 1777777777777777777777   [-1 decimal]<BR>
   &nbsp;&nbsp;&nbsp;C (o):            37777777777   [-1 decimal]</CODE><P>

   You can optionally adjust the behaviour in CFmt via the constructor
   or with the method "void setHexByteCnt(int)". You would have to pass
   an integer specifying the maximum number of bytes that should be used
   for display. This could be four or eight. All other values will NOT
   change the behaviour!<P>

   CFmt cv = new CFmt(4) will switch to the C behaviour, default is the
   Java behaviour with 8 bytes displayed.<P>

   You can always query the value with "int getHexByteCnt()".<P>




 <LI> Type 'u' (unsigned) kann ONLY display bytes, shorts or ints, if you
   want to display longs, you would have to use 'd', 'i', 'o', 'p', 'x',
   or 'X'. (Funnily, I did not manage to display a "long long" or similar
   in C via printf - but I did not look too close into these mechanics.)<P>



 <LI> precision and / or minimum field width can be 320 maximum.
   Bigger Values will be shortened to 320.<P>



 <LI> If type specifications don't match the value, an empty string will be
   returned. Example:<P><CODE>

     fmt("Hello","%f");</CODE><P>

   So far I did allow two exceptions: Strings with "%c" and Characters
   with a format specifier of "%s".<P>


 <LI> Format specifier not sticking to the below detailed scheme will lead
   to "some" result, but the behaviour is not clearly defined. Definately
   the behaviour is different to the behaviour under C in our environment.<P>
 </UL>


 <B>Excerpt of the manpage used as the basis for the CFmt class:</B><P>

  [...]<P>

     Each conversion specification is introduced by the character
     %.  After the %, the following appear in sequence:<P>

          Zero or more flags, which modify  the  meaning  of  the
          conversion specification.<P>

          An optional decimal digit string specifying  a  minimum
          field  width.  If the converted value has fewer charac-
          ters than the field width, it will  be  padded  on  the
          left  (or  right,  if  the  left-adjustment  flag  `-',
          described below, has been given) to  the  field  width.
          The padding is with blanks unless the field width digit
          string starts with a zero, in which case the padding is
          with zeros.<P>

          A precision that gives the minimum number of digits  to
          appear  for  the  d,  i, o, u, x, or X conversions, the
          number of digits to appear after the decimal point  for
          the e, E, and f conversions, the maximum number of sig-
          nificant digits for the g and G conversion, or the max-
          imum  number  of characters to be printed from a string
          in s conversion.  The precision takes  the  form  of  a
          period  (.)  followed by a decimal digit string; a NULL
          digit string is treated as zero.  Padding specified  by
          the  precision  overrides  the padding specified by the
          field width.<P>

          An optional l (ell) specifying that a following  d,  i,
          o,  u,  x,  or X conversion character applies to a long
          integer arg.  An l before any other conversion  charac-
          ter is ignored.<P>

>[Note: I did never(!) see any difference between the output with
> a specification containing an additional 'l' and a specification
> not containing the 'l'.]<P>

          A character that indicates the type of conversion to be
          applied.<P>

     A field width or precision or both may be  indicated  by  an
     asterisk  (*)  instead  of a digit string.  In this case, an
     integer arg supplies the field width or precision.  The  arg
     that  is actually converted is not fetched until the conver-
     sion letter is seen, so the args specifying field  width  or
     precision  must  appear  before  the arg (if any) to be con-
     verted.  A negative field width argument is taken as  a  `-'
     flag  followed  by a positive field width.  If the precision
     argument is negative, it will be changed to zero.<P>

     The flag characters and their meanings are:<P>
     -         The  result  of  the  conversion  will  be   left-
               justified within the field.<BR>
     +         The result of  a  signed  conversion  will  always
               begin with a sign (+ or -).<BR>
     blank     If the first character of a signed  conversion  is
               not  a  sign,  a  blank  will  be  prefixed to the
               result.  This implies that  if  the  blank  and  +
               flags both appear, the blank flag will be ignored.<BR>
     #         This flag specifies that the value is to  be  con-
               verted  to an "alternate form."For c, d, i, s, and
               u conversions, the flag  has  no  effect.   For  o
               conversion,  it  increases  the precision to force
               the first digit of the result to be a zero.  For x
               or X conversion, a non-zero result will have 0x or
               0X prefixed to it.  For e, E, f, g, and G  conver-
               sions,  the  result  will always contain a decimal
               point, even if no digits follow  the  point  (nor-
               mally,  a  decimal  point appears in the result of
               these conversions only if  a  digit  follows  it).
               For  g and G conversions, trailing zeroes will not
               be removed from the result  (which  they  normally
               are).<P>

     The conversion characters and their meanings are:<P>

     d,i,o,u,x,X<BR>
               The integer arg is converted to signed decimal  (d
               or  i),  unsigned octal (o), unsigned decimal (u),
               or  unsigned  hexadecimal  notation  (x  and   X),
               respectively;  the  letters  abcdef are used for x
               conversion and the letters ABCDEF  for  X  conver-
               sion.   The precision specifies the minimum number
               of digits to appear; if the value being  converted
               can  be  represented  in  fewer digits, it will be
               expanded with leading zeroes.  (For  compatibility
               with  older  versions, padding with leading zeroes
               may alternatively be  specified  by  prepending  a
               zero  to  the field width.  This does not imply an
               octal value for the  field  width.)   The  default
               precision  is  1.  The result of converting a zero
               value with a precision of zero is a NULL string.<BR>
     f         The float or double arg is  converted  to  decimal
               notation  in the style [-]ddd.ddd where the number
               of digits after the decimal point is equal to  the
               precision  specification.   If  the  precision  is
               missing, 6 digits are given; if the  precision  is
               explicitly  0,  no digits and no decimal point are
               printed.<BR>

     e,E       The float or double arg is converted in the  style
               [-]d.ddde+ddd, where there is one digit before the
               decimal point and the number of digits after it is
               equal  to  the  precision;  when  the precision is
               missing, 6 digits are produced; if  the  precision
               is  zero,  no decimal point appears.  The E format
               code will produce a number with  E  instead  of  e
               introducing  the  exponent.   The  exponent always
               contains at least two digits.<BR>
     g,G       The float or double arg is printed in style f or e
               (or  in  style  E in the case of a G format code),
               with the precision specifying the number of signi-
               ficant  digits.   The  style  used  depends on the
               value converted:  style e or E will be  used  only
               if  the  exponent resulting from the conversion is
               less  than  -4  or  greater  than  the  precision.
               Trailing  zeroes  are  removed  from the result; a
               decimal point appears only if it is followed by  a
               digit.<P>

     The e, E f, g, and G formats print IEEE indeterminate values
     (infinity  or  not-a-number)  as "Infinity" or "NaN" respec-
     tively.<P>

     c         The character arg is printed.<BR>
     s         The  arg  is  taken  to  be  a  string  (character
               pointer)   and  characters  from  the  string  are
               printed until a NULL character (\0) is encountered
               or until the number of characters indicated by the
               precision specification is reached.  If the preci-
               sion  is  missing,  it is taken to be infinite, so
               all characters up to the first NULL character  are
               printed.   A  NULL  value for arg will yield unde-
               fined results.<BR>
     %         Print a %; no argument is converted.<P>

     In no case does a non-existent or small  field  width  cause
     truncation  of  a  field;  if  the result of a conversion is
     wider than the field width, the field is simply expanded  to
     contain  the conversion result.  Padding takes place only if
     the specified field width exceeds the actual width.  Charac-
     ters  generated  by printf() and fprintf() are printed as if
     putc(3S) had been called.<P>

[...]<P>

EXAMPLES<BR>
     To print a date and  time  in  the  form  "Sunday,  July  3,
     10:02,"  where  weekday  and  month  are  pointers  to NULL-
     terminated strings:<P><CODE>

          printf("%s, %s %i, %d:%.2d", weekday, month, day, hour, min);
<P></CODE>
[Note:
<P><CODE>
    System.out.print(cv.fmt("%s",weekday)+", "+<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.fmt("%s",month)+" "+<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.fmt("%i",day)+", "+<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.fmt("%d",hour)+":"+<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cv.fmt("%.2d",min));
<P></CODE>
  should be abbreviated to:
<P><CODE>
    System.out.print(weekday+", "+month+" "+day+", "+<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hour+":"+cv.fmt("%.2d",min));
<P></CODE>

  as in the first four places the CFmt conversion does nothing more than
  the default conversions in System.out.print().<BR>
]<P>

     To print pi to 5 decimal places:<P><CODE>

          printf("pi = %.5f", 4 * atan(1. 0));<P></CODE>
[Note: <BR><CODE>
  System.out.print("pi = "+cv.fmt("%.5f",4 * atan(1.0)));<BR></CODE>
]<P>

[...]<P>

     Very wide fields (>128 characters) fail.<P>

[Note: The limit in this class is about 320]<P>

[...]
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="CFmt.html#CFmt()">CFmt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates a new instance with a default of 8 as the hexByteCount.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="CFmt.html#CFmt(int)">CFmt</A></B>(int&nbsp;hexByteCnt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates a new instance with the specified value as hexByteCnt.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, byte)">fmt</A></B>(java.lang.String&nbsp;conv,
    byte&nbsp;bval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats a byte as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, char)">fmt</A></B>(java.lang.String&nbsp;conv,
    char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats a character as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, double)">fmt</A></B>(java.lang.String&nbsp;conv,
    double&nbsp;dval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats a double value as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, float)">fmt</A></B>(java.lang.String&nbsp;conv,
    float&nbsp;fval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats a float value as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, int)">fmt</A></B>(java.lang.String&nbsp;conv,
    int&nbsp;ival)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats an integer as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, long)">fmt</A></B>(java.lang.String&nbsp;conv,
    long&nbsp;lval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats a long value as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#fmt(java.lang.String, java.lang.String)">fmt</A></B>(java.lang.String&nbsp;conv,
    java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats a String as specified by the conversion specification.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#getHexByteCnt()">getHexByteCnt</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current value for hexByteCnt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="CFmt.html#setHexByteCnt(int)">setHexByteCnt</A></B>(int&nbsp;hexByteCnt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Hexadecimal-Byte-Count is ONLY relevant to negative numbers of one of
 byte, short and int and type of 'o', 'x', 'X', 'p'. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="CFmt()"><!-- --></A><H3>
CFmt</H3>
<PRE>
public <B>CFmt</B>()</PRE>
<DL>
<DD>This creates a new instance with a default of 8 as the hexByteCount.
<P>
<DT><B>See Also:</B><DD><A HREF="CFmt.html#setHexByteCnt(int)"><CODE>setHexByteCnt(int)</CODE></A></DL>
<HR>

<A NAME="CFmt(int)"><!-- --></A><H3>
CFmt</H3>
<PRE>
public <B>CFmt</B>(int&nbsp;hexByteCnt)</PRE>
<DL>
<DD>This creates a new instance with the specified value as hexByteCnt.
<P>
<DT><B>Parameters:</B><DD><CODE>hexByteCnt</CODE> - How many bytes a hexadecimal number will contain
 maximum (4 or 8).<DT><B>See Also:</B><DD><A HREF="CFmt.html#setHexByteCnt(int)"><CODE>setHexByteCnt(int)</CODE></A></DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setHexByteCnt(int)"><!-- --></A><H3>
setHexByteCnt</H3>
<PRE>
public void <B>setHexByteCnt</B>(int&nbsp;hexByteCnt)</PRE>
<DL>
<DD>The Hexadecimal-Byte-Count is ONLY relevant to negative numbers of one of
 byte, short and int and type of 'o', 'x', 'X', 'p'. It specifies how
 many bytes maximum a resulting hexadecimal number will contain.<P>
 Examples:<P>
 -1 will be displayed with a format of "%x" and hexByteCnt of 4 as:<P>
 <CODE>
 ffffffff
 </CODE><P>
 and with a hexByteCnt of 8 as:<P>
 <CODE>
 ffffffffffffffff
 </CODE><P>
 In C the default seems to be 4 bytes, the default here is 8 bytes.
 Possible values are 4 and 8, other values will NOT change the last value!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hexByteCnt</CODE> - How many bytes to use for output of negative
 hexadecimal numbers.</DL>
</DD>
</DL>
<HR>

<A NAME="getHexByteCnt()"><!-- --></A><H3>
getHexByteCnt</H3>
<PRE>
public int <B>getHexByteCnt</B>()</PRE>
<DL>
<DD>Returns the current value for hexByteCnt.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current value of hexByteCnt<DT><B>See Also:</B><DD><A HREF="CFmt.html#setHexByteCnt(int)"><CODE>setHexByteCnt(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, char)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            char&nbsp;c)</PRE>
<DL>
<DD>Formats a character as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may only contain the
 character 'c' as conversion character.<DD><CODE>c</CODE> - the char that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted character</DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, java.lang.String)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Formats a String as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may only contain the
 character 's' as conversion character.<DD><CODE>s</CODE> - the String that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted String</DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, byte)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            byte&nbsp;bval)</PRE>
<DL>
<DD>Formats a byte as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may contain the
 characters 'd', 'i', 'o', 'p', 'u', 'x' and 'X' as conversion
 characters.<DD><CODE>bval</CODE> - the byte value that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted byte value</DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, int)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            int&nbsp;ival)</PRE>
<DL>
<DD>Formats an integer as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may contain the
 characters 'd', 'i', 'o', 'p', 'u', 'x' and 'X' as conversion
 characters.<DD><CODE>ival</CODE> - the integer value that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted integer value</DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, long)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            long&nbsp;lval)</PRE>
<DL>
<DD>Formats a long value as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may contain the
 characters 'd', 'i', 'o', 'p', 'u', 'x' and 'X' as conversion
 characters.<DD><CODE>lval</CODE> - the long value that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted long value</DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, float)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            float&nbsp;fval)</PRE>
<DL>
<DD>Formats a float value as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may contain the
 characters 'f', 'e', 'E', 'g' and 'G' as conversion characters.<DD><CODE>fval</CODE> - the float value that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted float value</DL>
</DD>
</DL>
<HR>

<A NAME="fmt(java.lang.String, double)"><!-- --></A><H3>
fmt</H3>
<PRE>
public java.lang.String <B>fmt</B>(java.lang.String&nbsp;conv,
                            double&nbsp;dval)</PRE>
<DL>
<DD>Formats a double value as specified by the conversion specification.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>conv</CODE> - the conversion specification. It may contain the
 characters 'f', 'e', 'E', 'g' and 'G' as conversion characters.<DD><CODE>dval</CODE> - the double value that should become formatted
<DT><B>Returns:</B><DD>A String containing the formatted double value</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="Precompile.html" title="class in "><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="CFmt.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
