# İşlem Kutulama


İşlem Kutulama



 Robot Java programları yazarken, iş sistemlerinde cok kullandığımız bir tekniği kulanmaya basladığımızı farkettik. Donanım ağırlıklı olan bu ortamda arayüzler önemli olduğu için, bahsedeceğimiz teknik sürekli karsımıza çıkıyor. Bu kalıp 'işlem kutulamak' diye bilinir. Eğer tüm yazılımı birim testinden (unit testing) geçiriyorsanız, bu teknik çok işinize yarayacak.                Bu tekniği en son CmuCam4J projem içinde kullandım. CmuCam4J projesi, bir elektronik gözü JStamp Java devresine bağlıyarak, robotu evin içinde gezmesini sağlayacak. Geliştirme evriminden bahsetmek gerekirse: Yazılım disüstü bilgisayarda geliştirilir ve birim testine tabi tutulur. Sonra test için, yazılan Java kodlar JStamp üzerine aktarılır. JStamp üzerinde  calışırken kodumuz dış dünyadan bilgi alıp, kontrol için 1 ve 0 sinyalleri dışarıya vermek ile yükümlüdür. Dış dünya dediğimiz, seri port (RS-232) üzerinden kamera (CmuCam) ve kontrol için, iki pin (IOA04, IOC6) üzerinden Lego tekerlek motorları.              Boyle olunca, elimizde iki türlü kod var diyebiliriz. Bazı nesneler, işlem mantığı denen sayısal görüntü işleyen türden kodlar. Bu nesneler, seri port'tan alınmış olan görüntüleri işleyip,   içinden zemin, etraftaki cisimler hakkında bilgi çıkartıyor ve, bu bilgilere göre robotun gideceği yönü tayin ediyor. İkinci tür kod ise, dış dünya ile bağlantıyı idare ediyor, yani kamera bağlantısı, ve pinler üzerinde 0V yada +5V voltaj yaratmak gibi.. 5V elektronikte 1 değerine tekabul eder.               Görüntü işlemci kodlarına birim test uygulamak için, bu mantığı izole etmek lazımdır. Yani, kara kutuya kapatıp, sadece kutu içindekileri teste tabi tutmalı. Bunu nasıl yapacağız?              Neden yapmamız gerektiğini anlatalım öncelikle.. Bir mantığı birim test ederken, öteki birimlerden etkilenmemesi, yani onların varliğının test sonuçlarını etkilememesi gerekir. Yoksa birim test gerçek birim test olmaz. Eğer yazılımı Lego taşları gibi düşünürsek, her taşı önce kontrol edip sağlamlığına bakmak gerekir, ve eğer sağlamsa bütün yapıya eklenir. Eğer bu taşı ayırıp, kendi başına birim testine tabi tutmazsak, sonradan büyük yapının içinde hatalı olan bu taşı bulmakta zorluk çekeriz.           Java Yöntemi          Kara kutu yaratmak için en güzel yöntem, Java CLASSPATH öğesini kullanarak olacak. Bildiğimiz gibi, CLASSPATH Java komut yorumlayıcısına, derlenmiç nesneleri nerede bulacağını gösterir. (.class dosyalari) Eğer CLASSPATH /usr/local/java/class_dizini ise, "java com.ornek.Nesne" işlettiğiniz zaman /usr/local/java/class_dosyalari/com/ornek/ dizini altında Nesne dosyası bulunup calıştırılır.               Şimdi, diyelimki bizim görüntü işlemleri kendi dizini altında, ve bu dizindeki bir tanesi hariç bütün nesneler, zaten kutu içinde, yani kendi çöplüğünde işlem yapıyor. Bir nesne hariç. Bu nesne, dış dünyaya bağlantı kuran bir nesne, ismi Robot.java olsun. Robot nesnesi altında 'ileri git' geri git' gibi nesneler tanımlanmış, ve bu işlemler JStamp gerektiyor, yani sonuç ortamı! Günlük derleme yaparken dizüstü bilgisayarımızı kullanıyoruz, JStamp bağlantımız yok. (Zaten Robot nesnesini dizüstünde işletirseniz hata verecektir). Ne yapacağız? Dizüstü ortamında birim test icin ne yapacağız?               Hemen Robot.java dosyasini başka bir dizine kopyalayın. İşlemlerine teker teker gidip, içini boşaltın. Yani 'ileri git' işlemi hiç bir sey yapmasın. Bu boş haldeki nesneyi derleyin, ve şimdi sıkı durun, CLASSPATH sistem değişkenine gidip, yeni yarattığınız dizini en sona ekleyin! Böylece dizüstünde çalışırken, gerçek Robot değil, içi boş olan Robot calışacak. Böylece birim test yaparken (her derlemeden sonra değil mi?) sayısal görüntü işlemlerini kutuya kapatmış oldunuz. Artık sadece bu işlemleri test ediyorsunuz. Kutlarım.               Not: Burada CLASSPATH'ın sıralamaya verdiği öncelik özelliğini kullandık. Eğer yorumlayıc;, kullanılan herhangi bir nesneyi CLASSPATH altındaki birkaç dizinde bulursa, sadece 'en sondaki' dizinde bulunan nesne işletilir. Buna CLASSPATH'in öncelik sırası diyoruz.        




